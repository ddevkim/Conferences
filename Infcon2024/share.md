## INFCON2024

***

[Program](https://www.inflearn.com/conf/infcon-2024/session/?category=speaker)

## 지속 성장 가능한 설계를 만들어가는 방법(토스 페이먼츠 - 김재민)

### 일반적인 설계 개념 방식
- 어떤 서비스를 만든다
- 필요한 요소들을 나열한다
- 밀접한 관계끼리 개념을 묶는다.
- 묶인 그룹 간의 교집합을 형성한다.

### 격벽
- 개념간 그룹지어 격벽을 세우고
- 필요한 통신만을 허용해서 그 허용을 통해 연결

### 잘못된 제어와 통제
- 개념과 격벽이 class 로 설계가 되어 있고
- class 의 수정시 관련된 모듈만 정확하게 수정되어야 함.
- 아닌 경우, 서로 의존성이 잘못 연결된 형태일 가능성이 큼

### 예시
- 대출 (개념)
  - 신청 (action)
  - 실행 (action)
  - 상환 (action)

- 대출 (개념)
  - Loan
  - LoanService
- 신청 (개념)
- 실행 (개념)
- 상환 (개념)


### 요약
- 하나의 개념이 너무 많이 쓰이면 분리 검토
- 상태에 의해 개념이 발생하면 격벽을 세워볼 것을 검토

### 개념
- 자신의 비즈니스 서비스를 지탱하는 코어 로직
- 자신이 아닌 외부의 것들은 개념으로 넣어서는 안됨.
  - 우리가 제어할 수 없음.
  - 이런것들은 참조 불가의 영역으로 바로 내부 서비스로 들어오게 하면 안됨.
  - 외부 서비스의 데이터를 DB 에 수집만 하는 provider 모듈만 분리하고 격벽화 함.
  - 코어 내부 로직에는 외부 영역이 들어올 수 없음

### 소프트웨어의 설계 관점
- 소프트웨어는 소프트다.
- 설계 변경 사항에 대해 대응할 수 있는 설계를 해야 한다. 아닌 것은 소프트웨어로 하드웨어를 만든 거다.
- 요구사항은 항상 변함을 인정하고
- 완벽한 설계는 없고
- 유연하게 설계를 변경할 수 있어야 한다.
- 소프트웨어의 장점은 소프트하다는 것이다.

### 하지 말아야 할 것
- 성급한 설계는 변경점에 취약해진다.
- 과도한 설계는 불필요하다.
- 그래서 필요한 만큼한 설계한다.

### 어떻게 시작할까.
- 잘못된 예
1. 분석
2. 설계
3. 구현

- 좋은 예
1. 분석과 설계를 하지 말고
2. 구현만 빠르게 하고 <-- 테스트 --> 피드백/증명 이터레이션만 계속 돌리면
3. 결국 좋은 설계가 나온다.

### 요약

- 개념을 잡고
- 격벽을 세우고
- 구현을 채워나가
- 설계를 완성한다


***

## 디버깅 마인드셋 (김동희)

### 디버깅 패턴

- 개발 고수들을 인터뷰하면서 디버깅을 잘 하기 위한 패턴을 추출

1. 원인파악 (5) + 해결 (3) + 사후처리 (2)
2. 원인파악이 디버깅 전문성의 핵심 패턴
   1. 정상적인 환경과 비교 해서 심적 표상을 잘 그려야 함.
   2. 정상적인 상황에 대한 동작에 대한 해상도 높은 트리가 구축되어 있음.
3. 원인 파악의 단계
   1. 정상적인 동작에 대한 정의 (심정 표상 생성)
      1. 어떤 조건에서
      2. 어떤 순서로
      3. 어떤 이리들이 벌어져야 하는가
   2. 정상 동작에 대한 테스트 정의했으면 재현 환경 구축
      1. 버그 환경
      2. 동작 순서
      3. 코드를 격리해 가면서, 환경을 격리해 가면서 테스트
   3. 동작의 차이를 발생시키는 다양한 원인을 3가지 정도 기술
   4. 가설 검증
   5. 가설 검증에 실패하면 1-4 를 반복하지만 시간을 너무 많이 투자하는 것보다 헬프를 요청하거나 사고 전환이 필요한지 검토

- 참조
  - front 에서 디버거를 잘 활용하면 좋다.
  - TDD (Toilet driven dev) 물을 많이 마시고 20분 마다 강제 회고를 통해 방향을 세밀하게 조정
  - DDD (Description driven dev) PR 기반으로 작은 단위로 잘 쪼개서 읽는 사람을 위한 PR 을 하려고 노력
  - ISS (Issue driven dev) 최소 작용 코드를 생산해서 issue 를 정의하려고 노력

***

## ProxySQL 을 활용하여 데이터베이스 대용량 트래픽 처리 (강성욱)

### 시스템의 안정화

- 단일실패 지점을 찾고 해당 지점을 견고하게 함.
- 보통 DB 가 endpoint 이기 떄문에 단일 실패 지점이 되고 서비스 전체 장애로 퍼짐

### 데이터 베이스 성능 확장이 어플리케이션에 비해 어려움
- 물리적 데이터
- 재배치에 대한 오버헤드
- 실시간 트래픽

### 일반적인 솔루션
- 리플리카
  - Primary(write) >> 다수의 Secondary(read)
    - 성능에 대한 부하 분산은 읽기만 됨
    - write 는 1개라 병목해결이 안됨
    - read 싱크 부하와 시간차 문제
    - application 에서 R, W 커넥션도 분리해 줘야 실제 분산이 의미있게 됨.
- 샤딩
  - 실제 쓰기를 분산함
  - 장애 지점이 발생해도 해당 데이터가 손실된 상태로 운영 (대신에 나머지는 안정)

### 커넥션 관리
- DB 커넥션 연결시 큰 오버헤드가 발생함
  - 인증인가, 권한체크, 로깅 등에 의해 CPU 부하
  - 그리고 커넥션 당 메모리 할당이 필요함 (약 2MB)
    - 메모리 관리, 메모리 조각화 등에 의해 CPU 부하가 가중됨.
- 따라서 커넥션 풀을 사용함.
  - 일정 개수의 커넥션을 미리 연결해 놓고 풀에 넣어서 재사용
  - 커넥션 오버헤드 제거됨
  - 요청이 들어오면 커녁션 조회하고, 커넥션을 반환함.  
- 커넥션과 풀의 장단점과 비율에 대해 조사 (TODO)


### 실제 사례
- 아무리 서버와 DB 커넥션을 늘린다고 해도 커넥션 수, 커넥션 풀만 고민하면 안되고
- 네트워크 전단계부터 전체적인 흐름을 고려해야 함.
- 예를 들면, 동접자가 몰릴 떄 스위치 CPU 의 부하가 세션 테이블이 꽉차서 문제가 발생함.

### DB Failover 가 발생하면,
- 자동으로 DB 는 장애 발생시 failover 로 넘어간다.
- 그러나 IP 변경에 대해 자동화가 되어야 함. DNS 로 연결되어도 DNS IP 캐시 타임도 고려되어야 함.
- DB 가 failover 되거나 replica 가 추가되거나 할 때 유연하게 대응될 수 있도록 cluster IP 로 묶여 있어야 함.

### 이런 불편함들을 제거할 수 있는 한가지 솔루션이 PROXY SQL
- [proxysql url](proxysql.com)
- 연결 예시
  - proxy-sql
  - master
  - slave1
  - slave2
- Application --- proxy --- db
  - application 개발자에게는 proxy 의 접근까지의 crendential 만 노출됨.
  - proxy 서버에서 DB 의 crendential 이 관리되는 것으로 격리됨.
- 로드밸런싱 기능을 알아서 제공 (round robin)
- application 은 R, W 구별없이 개발하고 proxy 가 알아서 처리
  - 쿼리 룰을 작성해서 어떤 커맨드는 어떤 hostgroup 으로 가게 할지 정할 수 있음.
    - 예) SELECT 는 host_group2 (read 만 있는) 로만 보내도록 규칙 가능.
- PMM (Percona Monitoring and Management) 서비스에서 프록시 모니터링이 가능 (무료)

### notes
- ProxySQL 은 커넥션만 관리하지 DB failover 를 해주지 않음.
  - Orchestrator 서비스를 사용해서 failover 방지
- ProxySQL 를 계층화 할 수도 있음.

### ProxySQL 도 단일 실패 지점이 되지 않도록 하기 위해 ProxySQL 도 클러스터로 연결

***

## 마이그레이션 (인프런)

***

### 서비스 변경 비교

- 기존 서비스
  - nodejs + express
  - SSR (pug ejs template)
  - 렌더링 이후 js 에서 event register
- 신규 서비스
  - next.js + vite + react

### 마이그레이션 이슈 해결

- 기능 플래그를 통해 구 + 신 기능을 선택적으로 서빙 (쿠키 등 사용)
  - 배포안정성 높임
  - 유저에게 점진적 신규 기능 적용
  - 내부 프로덕션 테스트 가능
- 기존 ejs 레이아웃에서 특정 영역만 React 컴포넌트로 렌더링
  - SSR 에서 root_id div 를 삽입하고
  - vite 로 빌드된 js 를 script 에 같이 서빙하여
  - CSR 이 해당 영역만 일어나도록 설계
- 전역 css 가 react component 내부 요소까지 의도치 않게 영향을 미침
  - shadow DOM 을 사용
  - 특정 DOM component 를 지역적으로 분리해서 외부 css 요소가 영향을 미치지 않게 함.
- 공용 라이브러리에 대한 개별 패키지의 배포 주기를 싱크 맞춰야 하는 니즈
  - Module Federation
- 기존 router 를 redirect 시키지 않고 나이스하게 하는 방법
  - cloudfront behavior 기능 사용
  - Reverse Proxy server 사용 (기존 CF 에서 하는 역할을 대체)

### Wrapup
- 기능플래그를 통한 안정적, 점진적 배포
- 레거시 + 신규 패키지 믹스
- 공용 라이브러리 관리
- Module Federation
- CF Behavior + Reverse proxy
