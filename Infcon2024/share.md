## INFCON 2024

***

[Program](https://www.inflearn.com/conf/infcon-2024/session/?category=speaker)

## 지속 성장 가능한 설계를 만들어가는 방법(토스 페이먼츠 - 김재민)

### 좋은 설계 방식
- 어떤 서비스를 만든다고 했을 때 
- 기능에 필요한 요소들을 나열한다
- 밀접한 요소를 묶어 "개념" 을 생성한다.
- 개념과 process 를 잘 구분하는 것이 중요
- 개념 단위로 파일을 만들고 해당 개념을 사용하는 프로세스 파일을 생성
- 개념간에 격벽을 세워 도식화

### 개념
- 자신의 비즈니스 서비스를 지탱하는 코어 로직
- 자신이 아닌 외부의 것들은 개념으로 넣어서는 안됨.
  - 코어 내부 로직에 외부 영역이 들어오지 못하게 설계해야함.
  - 이런것들은 참조 불가의 영역으로 바로 내부 서비스로 들어오게 하면 안됨.
  - 외부 서비스의 데이터를 별도의 DB 에 수집만 하는 provider 모듈만 분리하고 내부 코어 로직과 직접적인 의존성은 제거.
- 개념은 주요 클래스 주체들을 말하는 것 같음.

### 격벽 
- 개념간 그룹을 짓고 격벽을 세우고 격벽을 통해 통신이 이루어지도록 설계.
- 인터페이스를 말하는 것 같음.
- 개념간 필요한 통신만을 허용.

### 설계팁
- 하나의 개념이 너무 많은 기능 주체를 포함하면 분리할 수 있는지 검토
- 상태에 의해 개념이 발생하면 격벽을 세워볼 것을 검토
- 개념 수정시 발생시 관련된 프로세스만 파일 수정이 나타나야 함.
- 여러 파일들을 건드려야 하거나
- 의존성이 있어보이는 프로세스인데 해당 파일이 수정이 일어나지 않는 경우 잘못 설계된 가능성이 큼

### 소프트웨어의 설계 마인드
- 소프트웨어와 설계 변경과의 관계
  - 소프트웨어는 SOFT 해야함을 명심.
  - 애초부터 설계 변경에 유연하게 대응할 수 있는 설계를 해야 함을 받아들여야 함.
  - 많은 개발자들이 설계 변경을 싫어하지만 그건 나쁜 자세.
  - 그런 개발자는 소프트웨어로 하드웨어를 만든 거다. 하드웨어는 보통 제작 후에 수정변경이 어려운 특성을 가진다. (롯데타워를 이제와서 10m 뒤로 이동시킬 수 없다.)
  - 요구사항은 항상 변할 수 있음을 자연스러운 것이라 인정하고
  - 완벽한 설계는 없고
  - 유연하게 설계를 변경할 수 있는 소프트웨어를 만들기를.
- 설계의 밸런스
  - 성급한 설계는 변경점에 취약해짐
  - 과도한 설계는 불필요
  - 그래서 필요한 만큼한 설계하는 관점을 항상 고려

### 요약
- 개념을 잡고
- 격벽을 세우고
- 구현을 채우고 테스트 피드백 이터레이션을 돌려
- 설계를 완성한다.

***

## 디버깅 마인드셋 (김동희)

### 디버깅 패턴
- 현업 개발 고수들을 인터뷰하면서 디버깅을 잘 하기 위한 패턴을 추출하는 노력을 함.
- 인지심리학적으로 디버깅을 접근해 보면 체계화가 가능했다고 함.

1. 디버깅에 쏟는 시간 적정 비율
   1. 원인파악 (50 %)
   2. 해결 (30 %)
   3. 사후처리 (20 %)
2. 원인파악이 디버깅 전문화의 핵심
   - 정상적인 상황에 대한 동작에 대한 해상도 높은 심적 표상 트리가 구축되어 있음.
3. 원인 파악의 단계
   1. 정상적인 동작에 대한 정의를 정확히 글로 쓰고 설명할 수 있어야 함.
      1. 어떤 조건에서
      2. 어떤 순서로
      3. 어떤 일들이 벌어져야 하는가
   2. 정상 동작을 정의했으면 재현 단계
      1. 버그 환경에 대한 환경 파악
      2. 동작 순서와 같은 좁힐 수 있는 제약 조건을 적용
      3. 코드를 격리해 가면서, 환경을 격리해 가면서 재현 테스트
   3. 가설 구축
      - 정상동작 명세와 버그 재현 상태의 차이를 발생시키는 원인을 < 3가지 정도 기술해봄
   4. 가설 검증
   5. 위 단계 이터레이션
      - 가설 검증에 실패하면 1-4 를 반복
      - 매몰되어 시간을 너무 많이 투자하는 것보다 다른 개발자에게 도움 요청하거나 사고 전환이 필요한지 검토

- 팁들
  - Front 에서 디버깅을 잘 하려면 디버거를 잘 활용하는 개발자가 유리함.
  - 괜찮은 습관들
    - TDD (Toilet driven dev) 물을 많이 마시고 20분 마다 강제 회고를 통해 방향을 세밀하게 조정
    - DDD (Description driven dev) PR 기반으로 작은 단위로 잘 쪼개서 읽는 사람을 위한 PR 을 하려고 노력
    - ISS (Issue driven dev) 최소 작용 코드를 생산해서 issue 를 정의하려고 노력

***

## ProxySQL 을 활용하여 데이터베이스 대용량 트래픽 처리 (강성욱 DBA)

### DBA 는 시스템의 안정적인 서비스에 목숨을 거는 사람들

- 단일실패 지점을 찾고 해당 지점을 제거하거나 실패 범위를 축소
- 보통 DB 가 서비스의 엔드포인트이기 떄문에 단일 실패 지점이 되고 서비스 전체 장애로 퍼짐

### 그러나 데이터 베이스 성능 확장이 어플리케이션에 비해 어려운 이유
- 물리적인 디스크 데이터
- 데이터 재배치에 대한 오버헤드
- 실시간 트래픽들

### 일반적인 솔루션
- 리플리카
  - Primary(write) - 다수의 Secondary(read)
    - 성능에 대한 부하 분산은 읽기만 되는 한계
    - write 는 1개라 병목해결이 안됨
    - read 싱크 부하와 시간차 문제
    - Application 에서 R, W 커넥션을 수동으로 코드 레벨에서 관리까지 해야 실제 레플리카가 의미있게 됨.
- 샤딩
  - 쓰기 분산
  - 장애 지점이 발생시 해당 데이터가 손실된 상태로 운영되어도 괜찮은 형태로 어플리케이션 개발 (대신에 나머지는 장애 내성)

### 커넥션 관리
- 커넥션
  - DB 커넥션 연결시에 큰 오버헤드가 발생하므로 잦은 커넥션은 연결은 좋지 못함.
  - 인증인가, 권한체크, 로깅 등에 의해 CPU 부하
  - 그리고 커넥션 당 메모리 할당이 필요함 (약 2MB)
    - 메모리 관리, 메모리 조각화 등 CPU 부하가 가중.
- 풀
  - 일정 개수의 커넥션을 미리 연결해 놓고 풀에 넣어서 재사용
  - 커넥션 오버헤드 제거됨
  - 요청이 들어오면 커녁션 조회하고, 커넥션을 반환함.  
- QA. 적정 수준의 풀?
  - 최대의 풀 수로 운영한 다음 줄여나가는 접근이 올바름


### 팁
- 아무리 서버와 DB 커넥션을 늘린다고 해도 커넥션 수, 커넥션 풀만 고민하면 안되고
- end to end 네트워크 전단계부터 전체적인 흐름을 고려해야 함.
- 예를 들면, 동접자가 몰릴 떄 DB 는 널널해도 스위치 세션 테이블이 꽉차서 문제가 스위치 CPU 부하로 문제가 발생할 수 있음.

### DB Failover 가 발생하면,
- 자동으로 DB 는 장애 발생시 failover 될 수 있지만,
- IP 변경에 대해 자동화가 되어야 함. DNS 로 클러스터링 되어 있어도 DNS IP 캐시 타임도 고려되어야 함.
- DB 가 failover 되거나 replica 가 추가되거나 할 때 유연하게 대응될 수 있도록 clustering 도 잘 설계되어야 함.

### proxySQL
- [proxysql url](proxysql.com)
- open source 라 비용 없음.
- Application --- proxy --- db 혹은 proxy 를 여러 계층으로 둘 수도 있음.
  - application 개발자에게는 proxy 의 접근까지의 credential 만 노출됨.
  - proxy 서버에서 DB 의 credential 관리.
- 로드밸런싱 기능을 알아서 제공
  - round robin
  - replica db 성능에 기반하여 weighted round robin 설정도 가능
- application 코드는 R, W 구별없이 개발하고 proxy 가 알아서 처리
  - 쿼리 룰을 작성해서 command - hostgroup 매핑 가능
    - 예) SELECT 는 host_group2 (read 만 있는) 로만 보내도록 규칙화.
- 모니터링?
  - PMM (Percona Monitoring and Management) 서비스에서 프록시 모니터링이 가능 (역시 오픈소스)

### notes
- ProxySQL 은 커넥션만 관리하지 DB failover 를 해주지 않음.
  - Orchestrator 서비스 필요
- ProxySQL 를 여러 계층화 할 수도 있음.
  - 인프라 설계는 매우 다양함. case by case.
- ProxySQL 도 단일 실패 지점이 되지 않도록 하기 위해 ProxySQL 도 클러스터로 연결
- Aurora 쓰면 proxy 하는 역을 다 해주므로 proxy 고려할 필요 없음. (단, 비용)
- aurora + rds 조합에서 proxySQL 은 니즈가 크지는 않을 것 같고 개념적으로 학습만 해두면 좋을 것 같음.

***
## 인프런 프론트엔드 마이그레이션 여정 (인프랩 조성륜)

### 인프런의 서비스 기술스택 변경 전/후

- 기존 서비스
  - nodejs + express
  - SSR (pug ejs template)
  - 렌더링 이후 CSR
- 신규 서비스
  - next.js + vite + react

### 고민한 마이그레이션 전략들

- 기능 플래그를 통해 구 + 신 기능을 선택적으로 서빙 (쿠키 등 사용)
  - localstorage cookie 에 기능 플래그를 둠
  - 기능 플래그에 따라 router 에서 서빙 소스 분기 처리
    - 배포안정성 높임
    - 유저에게 점진적 신규 기능 적용
    - 내부 프로덕션 테스트 가능
- 기존 ejs 레이아웃에서 특정 영역만 React 컴포넌트로 분리
  - SSR 에서 root_id div 를 삽입하고
  - vite 로 빌드된 js 를 S3 에 올려놓고 script 에 같이 서빙하여
  - CSR 이 해당 영역만 일어나도록 설계
- 전역 css 가 react component 내부 요소까지 의도치 않게 영향을 미침
  - shadow DOM 을 사용
  - 특정 DOM component 를 지역적으로 분리해서 외부 css 요소가 영향을 미치지 않게 함.
  - 그러나 나중에 react 사용부와 legacy 코드와의 의존성이 필요하게 되어 결국 전체 코드를 react 로 전환하면서 shadow DOM 을 제거
- 마이크로 프론트엔드 아키텍쳐를 적용해서 팀별로 개발 분리
  - 공용 모듈에 대한 번들링 중복에 대한 비효율 발생
  - 새로운 피처 개발시 모든 팀 간의 배포 가능 주기가 달라서 피쳐 기능이 일부분에만 미적용되는 사례가 발생
  - module federation 사용으로 해결함.
    - 공용 모듈을 번들링된 같은 파일을 참조해서 동적 임포트해서 사용하게 하는 기술
    - webpack5 기본 지원하고 vite 는 플러그인으로 지원하는 것 같음
- 기존 routing 을 유지하면서 새로운 기능 제공
  - cloudfront behavior + Reverse Proxy 설정 (아마 nginx)

***

## 객체지향은 여전히 유용한가? (조영호)

### 주장
- 객체지향이 필요한지에 대한 질문보다 객체지향이 언제 필요한지에 대해 구별할 수 있어야 함.
- 모든 설계는, 모든 패러다임은 다 자신의 용도가 있음. 특정한 상황으로 인해 어떤 기술이나 패러다임이 좋다 안좋다고 판단하지 말것.
- 케이스 별로 기술의 적합성을 따지는 시각이 필요
- 데이터를 가공하고 처리하는데 집중하는 것이라면 절차지향이 비용이 낮음
- 행동 중심이라면 객체지향
- 필요한 곳에 맞게 사용

### 백엔드 계층별 관점
1. Presentation Layer: 사용자 인터페이스와 상호작용, API 엔드포인트 처리
2. Application Layer: 비즈니스 프로세스와 워크플로우 관리, 트랜잭션 처리
3. Domain Layer: 비즈니스 엔티티와 핵심 비즈니스 규칙 정의
4. Persistence Layer: 데이터 저장 및 검색, 데이터베이스 상호작용
- 위 계층 중 실제로 객체지향이 유리한 곳은 Domain Layer 정도 밖에 없음.


***
## 성장하지 않아도 괜찮습니다. (김영재)
- 성장에 대한 연사의 관점
  - 성장이라는 말이 유행하고 사람들에게 부담감을 주는 트렌드는 좋은 문화가 아니다.
  - 성장을 하지 말자는 것이 아니라 꾸준함을 강조하는 문화가 더 바람직하다.
- 추천글, 책
  - 개발자에서 아키텍트로 [추천책](https://product.kyobobook.co.kr/detail/S000001810394)
  - 오픈소스 답게 소프트웨어 설계하기 [추천글](https://techblog.lycorp.co.jp/ko/designing-software-like-an-open-source)
  - 유저의 VOC 를 프로덕트에 녹여내기 위한 노력 [추천글](https://techblog.lycorp.co.jp/ko/abc-user-feedback)
- 엔지니어링에 대한 관점
  - 재생산 비용을 0에 수렴하도록 노력을 하는 것이 엔지니어링의 핵심
  - 따라서 엔지니어링은 개발자에게만 적용하는 단어가 아니다.
  - 모두가 비슷한 일을 계속 하게 되면 자동화를 조금씩 쌓아서 점점 더 많은 output 을 나중에는 수행할 수 있어야 함.
  - 회고를 해야하는 이유가 다음번 비슷한 작업에서 재생산 비용을 줄이는 것에 있지 않을까.
- 팁
  - 사내 블로그에 정제된 글을 작성하는 습관이 큰 도움이 됨
    - 컨텍스트를 알지 못하는 팀 외부 사람에게 기술의 시작과 끝을 정리해서 설명하는 훈련이 됨
- 해결해하는 문제를 발견하기
  - 소통 중에 반복되는 질문들 속에서 힌트를 찾자
- BAN 로드맵
  - 자체 컨셉 개발 > 전체 프로덕트 팀 사용
  - 세로축 : B(basic)A(advanced)N(new value)
  - 가로축 : 프로덕트 흐름
  - 프로덕트 흐름에 따라 각 단계별 기능을 수준별로 브레인 스토밍
- 데이터 기반으로 의사 결정하기
  - 강조하고 싶은 데이터는 유저 피드백
- 무언가를 꾸준하게 하다보면 자신의 아이덴티티와 키워드가 자연럽게 생겨남.
  - 성장을 강요하기보다는
    - 많이.
    - 함께.
    - 크게.
    - 오래.
    - 일을 하는 개발자가 되길.
